<!doctype html>
<meta charset="utf-8">
<title> client </title>

<style>
  body {
    margin: 0px;
  }
  form {
    position: absolute;
    right: 0px;
    top: 0px;
  }
  form input {
    display: block;
    height: 20px;
    width: 30px;
    margin: 10px;
  }
  .hidden {
    display: none;
  }
</style>

<form id=bar action=http://localhost:8080/upload enctype=multipart/form-data method=post target=uploader>
  <input name=color  type=color>
  <input name=width  type=number value=1 min=1 max=10>
  <input name=tool   type=radio  value=pen checked> draw
  <input name=tool   type=radio  value=eraser> erase
  <input name=tool   type=radio  value=hand> move
  <input name=upload type=file>
  <input type=submit value=submit>
  <input type=button value=download onclick=snapshot()></form> 
</form>

<canvas id=canvas resize></canvas>

<iframe id=uploader src=http://localhost:8080 class=hidden height=500 width=700></iframe>

<script src=./lib/paper.js></script>
<script src=./lib/webrtc.js></script>
<script>

  var channel = new WebRTC.DataChannel('ws://localhost:1234'),
      bar = document.getElementById('bar');

  paper.install(window);

  window.onload = function () {
    paper.setup(canvas);

    var objects = {};         // SHARED synchronized objects map
    var currentRevision = -1; // Biggest key in objects
    var handle;       // LOCAL handle provide by the server for an under-construction object
    var buffer = [];  // LOCAL FIFO of objects waiting to be send to the server
    var history = []; // LOCAL Personal history for undo-redo
    var historyPointer= -1;

    /* UTILS */

    function redraw (since, data) {
      // first we erase all the objects after since
      for (var i = since; i < objects.length ; i++)
        if (objects[i]) objects[i].remove();
      var until = since + data.length;
      //console.log('currentRevision', until-1);
      for (var i = since; i < until ; i++) {
        if (data[i] != null)
          switch (data[i].type) {
          case 'raster':
            var raster = data[i];
            raster.handle = i;
            channel.handlers['raster'] (raster);
            break;
          default:
            objects[i] = rawToPath(data[i]);
          }
      }
      currentRevision = until - 1;
      paper.view.draw();
    }

    function rawToPath (raw) {
      var path = new paper.Path();
      //console.log('raw',raw);
      path.color = raw.color;
      path.strokeColor = raw.color;
      path.strokeWidth = raw.width;
      for (var i = 0 ; i < raw.segments.length ; i++) {
        path.add(new paper.Point(raw.segments[i].x, raw.segments[i].y));
        path.segments[i].handleIn = new paper.Point(raw.segments[i].handleInx, raw.segments[i].handleIny);
        path.segments[i].handleOut = new paper.Point(raw.segments[i].handleOutx, raw.segments[i].handleOuty);
      }
      if (raw.move) {
        path.translate(raw.move);
      }
      //console.log('rawtopath', path);
      return path;
    }

    function pathToRaw (path) {
      var segments = [];
      for (var i = 0 ; i < path.segments.length ; i++) {
        var seg = path.segments[i];
        segments.push({
          x: seg._point._x,
          y: seg._point._y,
          handleInx: seg._handleIn._x,
          handleIny: seg._handleIn._y,
          handleOutx: seg._handleOut._x,
          handleOuty: seg._handleOut._y
        });
      }
      return {
        segments: segments,
        color: path.color,
        width: path.strokeWidth
      };
    }

    function rasterToRaw (raster) {
      var raw = {};
      raw.id = raster._image.id.slice(3);
      //raw.position = { raster._position.x, raster._position.y };
      return raw;
    }

    /* NETWORK */

    // function building the client operations history
    function emitOperation (event, data) {
      if (buffer.length < 2) { // sync
        if (event == 'path') {
          buffer.shift();
          handle = undefined;
        }
        channel.send(event, data);
      }
    }

    function addToHistory (event, data, lostData) {
      historyPointer = history.push( {event: event, data: data, lostData: lostData} ) - 1;
      console.log('historyPointer', historyPointer);
    }
    

    // TODO make this the answer to "my handle is objects.length"
    channel.on('state', function(data) {
      //console.log('state',data);
      redraw(0, data);
      console.log('objects',objects);
    });

    // receive points from others
    channel.on('point', function(data) {
      //console.log('point number', data.handle);
      // the handle is bigger than our current revision: 
      // ==> we receive a new object!
      if (currentRevision < data.handle) { 
        objects[data.handle] = new paper.Path();
        currentRevision = data.handle;
        objects[data.handle].color = data.point.color; // don't remove this
        objects[data.handle].strokeColor = data.point.color;
        objects[data.handle].strokeWidth = data.point.width;
        //console.log('creation', objects[data.handle]);
      }

      // the handle is smaller than our revision but we don't have the object:
      // ==> we lose sync
      if (objects[data.handle] == null) {
        console.error('missed object', data.handle, ', ask for new state');
      } else { // expected behavior: add the new point to the object
        //console.log('expected', objects[data.handle]);
        objects[data.handle].add(data.point);
        paper.view.draw();
      }
    });

    // when other objects are finalized path
    channel.on('path', function(data) {
      console.log('path handle', data.handle);
      if(objects[data.handle])
        objects[data.handle].remove();
      objects[data.handle] = rawToPath(data.obj);
      paper.view.draw();
    });

    // receive raster images
    channel.on('raster', function(data) {
      //console.log('raster', data);
      var img = document.createElement('img');
      img.id = 'img' + data.id;
      img.src = 'http://localhost:8080/img/' + data.id;
      img.style.display = 'none';
      img.onload = function() {
        var raster = new paper.Raster(img.id);
        raster.type = 'raster';
        if (data.position != null) {
          raster.position = new paper.Point(data.position);
        } else {
          raster.position = new paper.Point(canvas.width/2, canvas.height/2);
        }
        objects[data.handle] = raster;
        console.log(raster);
        paper.view.draw();
      };
      currentRevision = data.handle;
      document.body.appendChild(img);
    });

    // the server gives us the handle to our current object
    channel.on('handle', function(data) {
      console.log('handle', data, 'buffer.length', buffer.length);
      handle = data;
      if (handle !== currentRevision + 1) console.error('our handle was late and we are doomed, ask for new state');
      objects[handle] = buffer[0];
      if (buffer.length > 1) {
        console.log('buffer was full, shifting');
        buffer.shift();
        channel.send('path', buffer[0]);
        handle = undefined;
      }
      currentRevision++;
    });

    // relative move of an object from it's current location
    channel.on('move', function(data) {
      //console.log('move', data);
      objects[data.handle].translate(data.move);
      paper.view.draw();
    });

    channel.on('delete', function(handle) {
      console.log('delete', handle);
      objects[handle].remove();
      paper.view.draw();
    });

    channel.on('close', function() {
      // TODO try to reconnect
      //channel = new WebRTC.DataChannel('ws://localhost:1234');
    });

    /* TOOLS */

    // create the tools
    var tool = new Tool(),
        tools = {};

    tool.onMouseDown = function (event) {
      var id = document.querySelector('input[name=tool]:checked').value;
      if (tools[id].onMouseDown !== undefined) {
        //console.log('calling',id,'onMouseDown');
        tools[id].onMouseDown(event);
      }
    };

    tool.onMouseDrag = function (event) {
      var id = document.querySelector('input[name=tool]:checked').value;
      if (tools[id].onMouseDrag !== undefined) {
        //console.log('calling',id,'onMouseDrag');
        tools[id].onMouseDrag(event);
      }
    };

    tool.onMouseUp = function (event) {
      var id = document.querySelector('input[name=tool]:checked').value;
      if (tools[id].onMouseUp !== undefined) {
        //console.log('calling',id,'onMouseUp');
        tools[id].onMouseUp(event);
      }
    };

    // PEN

    tools.pen = {};

    // A click begins the drawing of a new object
    tools.pen.onMouseDown = function (event) {
      buffer.push(new paper.Path());
      var path = buffer[buffer.length - 1];
      var point = event.point;
      point.color = bar.color.value;
      point.width = bar.width.value;
      emitOperation('point', point);
      path.add(point); 
      path.color = point.color; // duplicated information !
      path.strokeColor = point.color;
      path.strokeWidth = point.width;
    };

    // When the user drags the mouse, add points to current object and send them
    tools.pen.onMouseDrag = function (event) {
      var path = buffer[buffer.length - 1];
      path.add(event.point);
      emitOperation('point', event.point);
    };

    // When the mouse is released, we compress the current object
    tools.pen.onMouseUp = function (event) {
      var path = buffer[buffer.length - 1];
      //if (path._segments.length > 1) 
      path.simplify(10);
      paper.view.draw();
      var data =  { handle: handle, obj: pathToRaw(path) };
      emitOperation('path', data);
      addToHistory('path', data);
    };

    // ERASER
    
    tools.eraser = {};

    var eraserHitOptions = {
      stroke: true,
      fill: true,
      tolerance: 6
    };

    tools.eraser.onMouseDown = tools.eraser.onMouseDrag = function(event) {
      for(var i = currentRevision ; i >= 0 ; i--){
        if(objects[i] !== undefined){
          if(objects[i].hitTest(event.point,eraserHitOptions) != null){
            emitOperation('delete', i);
            switch(objects[i].type){
            case 'raster':
              addToHistory('delete', i, rasterToRaw(objects[i]));
              break;
            default:
              addToHistory('delete', i, pathToRaw(objects[i]));
            }
            objects[i].remove();
          }
        }
      }
      paper.view.draw();
    };

    // HAND

    tools.hand = {
      handle: undefined, // handle of the dragged object
      dragged: undefined, // dragged object itself
      from: undefined, // initial position of the object
      stand: undefined // last known position of the object
    };

    var handHitOptions = {
      stroke: true,
      fill: true,
      tolerance: 6
    };

    tools.hand.onMouseDown = function(event) {
      var hit = false; 
      var selected = currentRevision + 1;
      while (!hit && (selected > 0)) {
        selected--;
        if(objects[selected] !== undefined){
          if(objects[selected].hitTest(event.point,handHitOptions) != null){
            hit = true;
            tools.hand.handle = selected;
            tools.hand.dragged = objects[selected];
            tools.hand.from = event.point;
            tools.hand.stand = event.point;
          }
        }
      }
    };

    tools.hand.onMouseDrag = function(event) {
      if (tools.hand.dragged != undefined) {
        var move = new paper.Point(event.point.x - tools.hand.stand.x, event.point.y - tools.hand.stand.y) ;
        tools.hand.stand = event.point;
        tools.hand.dragged.translate(move);
        var data = { handle: tools.hand.handle, move: move };
        emitOperation('move', data);
        addToHistory('move',data);
        paper.view.draw();
      }
    };

    tools.hand.onMouseUp = function(event) {
      if (tools.hand.dragged != undefined) {
        var move = new paper.Point(event.point.x - tools.hand.from.x, event.point.y - tools.hand.from.y) ;
        addToHistory('move', { handle: tools.hand.handle, move: move });
        tools.hand.selected = undefined;
        tools.hand.dragged = undefined;
        tools.hand.from = undefined;
        tools.hand.stand = undefined;
      }
    };

    // HISTORY
  
    addEventListener('keydown', function(event) {
      if (event.ctrlKey)
        if (event.keyCode == 90){ // ctrl+z
          console.log('keydown', event);
          undo();
        }
        else if (event.keyCode == 89) // ctrl+v
          redo();
    });

    function undo () {
      if (historyPointer >= 0) {
        var operation = history[historyPointer];
        console.log('undo', operation);
        historyPointer--;
        switch (operation.event) {
        case 'path':
          channel.send('delete', operation.data.handle);
          channel.handlers['delete'] (operation.data.handle);
          break;
        case 'move':
          var inverse = new paper.Point(0 - operation.data.move.x, 0 - operation.data.move.y);
          channel.send('move', { handle: operation.data.handle, move: inverse });
          channel.handlers['move'] ({ handle: operation.data.handle, move: inverse });
          break;
        case 'delete':
          channel.send('path', {handle: operation.data, obj: operation.lostData});
          channel.handlers['path'] ({handle: operation.data, obj: operation.lostData});
          break;
        }
      }
    }

    function redo () {
      if (historyPointer < (history.length - 1)) {
        historyPointer++;
        var operation = history[historyPointer];
        //console.log('historyPointer', operation);
        channel.send(operation.event,operation.data);
        channel.handlers[operation.event] (operation.data);
      }
    }
  };

  function snapshot () {
    window.open(canvas.toDataURL("image/png"));
  }

</script>
