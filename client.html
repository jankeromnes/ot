<!doctype html>
<meta charset="utf-8">
<title> client </title>

<style>
  body {
    margin: 0px;
  }
  form {
    position: absolute;
    right: 0px;
    top: 0px;
  }
  form input {
    display: block;
    height: 20px;
    width: 30px;
    margin: 10px;
  }
</style>

<form id=bar>
  <input name=color type=color>
  <input name=width type=number value=1 min=1 max=10>
  <input name=tool  type=radio value=pen checked> draw
  <input name=tool  type=radio value=eraser> erase
  <input name=tool  type=radio value=hand> move
</form>

<canvas id=canvas resize></canvas>

<script src=./lib/paper.js></script>
<script src=./lib/webrtc.js></script>
<script>

  var channel = new WebRTC.DataChannel('ws://localhost:1234'),
      bar = document.getElementById('bar');

  paper.install(window);

  window.onload = function () {
    paper.setup(canvas);

    // create the state
    var path, handle, objects = [], history = [];
    var currentRevision = -1;
    var historyPointer;

    /* UTILS */

    function redraw (since, data) {
      // first we erase the object after since
      currentRevision = since + data.length - 1;
      console.log('currentRevision', currentRevision);
      for ( var i = since; i <= currentRevision ; i++){
        if( data[i] != null) {
          objects[i] = new paper.Path();
          rawToPath(data[i], objects[i]);
        }
      }
      paper.view.draw();
    }

    function rawToPath (raw) {
      var path = new paper.Path();
      path.strokeColor = raw.color;
      path.strokeWidth = raw.width;

      for (var i = 0 ; i < raw.curves.length ; i++) {
        path.add(new paper.Point(raw.curves[i].pointx, raw.curves[i].pointy));
        path.segments[i].handleIn = new paper.Point(raw.curves[i].handleInx,raw.curves[i].handleIny);
        path.segments[i].handleOut = new paper.Point(raw.curves[i].handleOutx,raw.curves[i].handleOuty);
      }
      return path;
    }

    function pathToRaw (path) {
      var curves = [];
      for (var i = 0 ; i < path.segments.length ; i++) {
        var seg = path.segments[i];
        curves.push({
          pointx: seg._point._x,
          pointy: seg._point._y,
          handleInx: seg._handleIn._x,
          handleIny: seg._handleIn._y,
          handleOutx: seg._handleOut._x,
          handleOuty: seg._handleOut._y
        });
      }
      return {
        curves: curves,
        color: path.color,
        width: path.strokeWidth
      };
    }
    // function building the client OT history
    function emitOperation (event, data, lostData) {
      channel.send(event, data);
      if (event == 'finalyse' || event == 'move' || event == 'delete')
        historyPointer = history.push( {event: event, data: data, lostData: lostData} ) - 1;
    }

    function undo () {
      if (historyPointer >= 0) {
        historyPointer--;
        var operation = history[historyPointer];
        switch (operation.event) {
        case 'finalyse':
          channel.send('delete', operation.handle);
        case 'move':
          var inverse = new paper.Point(-operation.data.x, -operation.data.y);
          channel.send('move', { handle: operation.handle, move: inverse }); 
        case 'delete':
          channel.send('finalyse', { handle: operation.handle, obj: operation.lostData });
        }
      }
    }

    function redo () {
      if (historyPointer < (history.length - 1)) {
        var operation = history[historyPointer];
        historyPointer++;
        channel.send(operation(event,data));
      }
    }

    /* NETWORK */

    // TODO make this the answer to "my handle is objects.length"
    channel.on('state', function(data) {
      console.log('state',data);
      redraw(0, data);
    });

    // receive points from others
    channel.on('point', function(data) {
      console.log('point', handle);
      // the handle is bigger than our current revision: 
      // ==> we receive a new object!
      if (currentRevision < data.handle) { 
        /* 
        while (currentRevision <= data.handle) {
          objects.push(new paper.Path()); //FIXME 
          currentRevision++;
        }*/
        objects[data.handle] = new paper.Path();
        currentRevision = data.handle;
        objects[data.handle].strokeColor = data.point.color;
        objects[data.handle].strokeWidth = data.point.width;
        console.log('creation', objects[data.handle]);
      }

      // the handle is smaller than our revision but we don't have the object:
      // ==> we lose sync
      if (objects[data.handle] == null) {
        console.error('missed object', data.handle, ', ask for new state');
      }
      else{ // expected behavior: add the new point to the object
        console.log('expected', objects[data.handle]);
        objects[data.handle].add(data.point);
        paper.view.draw();
      }
    });

    // the server gives us the handle to our current object
    channel.on('handle', function(data) {
      console.log('handle', data);
      handle = data;
      if (handle !== currentRevision + 1)
        console.error('our handle was late and we are doomed, ask for new state');
      objects[handle] = path;
      currentRevision++;
    });

    // when other objects are finalized
    channel.on('finalize', function(data) {
      objects[data.handle].remove();
      objects[data.handle] = rawToPath(data.obj);
      paper.view.draw();
    });

    // relative move of an object from it's current location
    channel.on('move', function(data) {
      objects[data.handle].translate(data.move);
      paper.view.draw();
    });

    channel.on('delete', function(handle) {
      objects[handle].remove();
      paper.view.draw();
    });

    channel.on('close', function(){
      // TODO
      //channel = new WebRTC.DataChannel('ws://localhost:1234');
    });
    /* TOOLS */

    // create the tools
    var tool = new Tool(),
        tools = {};

    tool.onMouseDown = function (event) {
      var id = document.querySelector('input[name=tool]:checked').value;
      if (tools[id].onMouseDown !== undefined) {
        console.log('calling',id,'onMouseDown');
        tools[id].onMouseDown(event);
      }
    };

    tool.onMouseDrag = function (event) {
      var id = document.querySelector('input[name=tool]:checked').value;
      if (tools[id].onMouseDrag !== undefined) {
        console.log('calling',id,'onMouseDrag');
        tools[id].onMouseDrag(event);
      }
    };

    tool.onMouseUp = function (event) {
      var id = document.querySelector('input[name=tool]:checked').value;
      if (tools[id].onMouseUp !== undefined) {
        console.log('calling',id,'onMouseUp');
        tools[id].onMouseUp(event);
      }
    };

    // PEN

    tools.pen = {};

    // A click begins the drawing of a new object
    tools.pen.onMouseDown = function (event) {
      path = new paper.Path();
      var point = event.point;
      point.color = bar.color.value;
      point.width = bar.width.value;
      emitOperation('point', point);
      path.add(point); 
      path.color = point.color; // duplicated information !
      path.strokeColor = point.color;
      path.strokeWidth = point.width;
    };

    // When the user drags the mouse, add points to current object and send them
    tools.pen.onMouseDrag = function (event) {
      path.add(event.point);
      emitOperation('point', event.point);
    };

    // When the mouse is released, we compress the current object
    tools.pen.onMouseUp = function (event) {
      path.simplify(10);
      paper.view.draw();
      emitOperation('finalize', { handle: handle, obj: pathToRaw(path) });
    };

    // ERASER
    
    tools.eraser = {};

    var eraserHitOptions = {
      segments: true,
      stroke: true,
      fill: true,
      tolerance: 6
    };

    tools.eraser.onMouseDown = tools.eraser.onMouseDrag = function(event) {
      path = new paper.Path();
      path.add(event.point);
      for(var i = currentRevision ; i >= 0 ; i--){
        if(objects[i] !== undefined){
          if(objects[i].hitTest(event.point,eraserHitOptions) != null){
            emitOperation('delete', i, lostData);
            objects[i].remove();
          }
        }
      }
      paper.view.draw();
    };

    // HAND

    tools.hand = {
      dragged: undefined, // object that is dragged
      from: undefined // initial position of the object
    };

    var handHitOptions = {
      segments: true,
      stroke: true,
      fill: true,
      tolerance: 6
    };

    tools.hand.onMouseDown = function(event) {
      path = new paper.Path();
      path.add(event.point);
      var selected = currentRevision + 1;
      var hit = false; 
      while (!hit && selected >= 0) {
        selected--;
        if(objects[selected] !== undefined){
          if(objects[selected].hitTest(event.point,handHitOptions) != null){
            hit = true;
            tools.hand.dragged = objects[selected];
            tools.hand.from = event.point;
          }
        }
      }
    };

    tools.hand.onMouseDrag = function(event) {
      if(tools.hand.dragged != undefined){
        var move = new paper.Point(event.point.x - tools.hand.from.x, event.point.y - tools.hand.from.y) ;
        tools.hand.from = event.point;
        tools.hand.dragged.translate(move);
        emitOperation('move', { handle: handle, move: move });
        paper.view.draw();
      }
    };

    tools.hand.onMouseUp = function(event) {
      selected = undefined;
      from = undefined;
    };
  };

</script>
